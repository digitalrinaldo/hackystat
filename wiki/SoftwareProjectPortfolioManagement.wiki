#summary An overview of software project portfolio management with Hackystat

= 1.0 Introduction =

== 1.1 Portfolio management for software projects ==

In large companies, it is possible to have dozens or even hundreds of
software projects underway at any given point in time.  This kind of scale
produces new challenges, as well as new opportunities for these companies.
Both challenges and opportunities result from the need of the company to
successfully understand and exploit their ownership of a "portfolio" of
software projects.

While the principles and practices of software project portfolio management (SPPM)
are not well understood, one can gain some initial insight into its
potential through analogy with financial portfolio management, for which
there are much better established guiding principles.  Just like a
financial portfolio, a software project portfolio should be managed in such
a way as to balance risk against reward, support performance assessment in
multiple ways, and gain insight into each "investment".

In the financial world, investors have a variety of ways to gain insight
into their portfolio.  First, they have the annual reports of their
companies, in which representatives of a company provide details about the
current status and future directions of their organization.  Second,
investors can use objective, standardized metrics such as share price
appreciation (or depreciation) over time, price/earnings ratios, and so
forth.  The standardized metrics have the advantages of being objective and
supporting baseline comparisons.  However, the annual reports and other
sources of subjective information about the organization provide an
important balance to the raw metrics which can put them into perspective,
and even lead the investor to think in terms of entirely different metrics
for evaluating that organization.

If you used only annual reports to manage your financial portfolio, then you might
never sell a stock that you currently own, and you might never by any stocks
other than those you currently own.  For many reasons, most of them
quite reasonable, annual reports tend to be optimistic.  So, this is a
suboptimal strategy.  On the other hand, if you used only standard metrics
like short-term share price change to manage your portfolio, then you
might end up with the worst-case scenario for financial portfolio
management: buying at the top and selling at the bottom.

Thus, the best approach for managing a financial portfolio is to gather
and integrate together a variety of types of information, both subjective and objective.

In the case of a software portfolio, the equivalent of the "annual report"
is typically already available: it is the monthly or
quarterly progress reports provided by the individual projects regarding
their current status and future directions. The goal of SPPM
is to integrate this subjective information with
an additional, objective, complementary source of information to senior
management.  Such information is analogous to standardized financial
metrics like price/earnings ratios. 

== 1.2 Benefits of SPPM for management ==

Just as a financial analyst combines together subjective and objective
information to gain insight into the portfolio, managers in a company with
a large number of projects can combine together subjective and objective
information to gain insight into how individual projects, as well as the
portfolio as a whole, is performing.  Specifically, project managers can learn:
  * Baseline process and product measures for the company as a whole. For example, over 200 Java projects, what is the median software structural quality (as measured by combining coverage, complexity, and coupling measures)? 
  * Normal and abnormal variation in process and product measures.  For example, what is a "typical" number of build failures for a project in a month?  Which projects are failing their builds significantly less than average?  Which are failing their builds significantly more? 
  * Organizational improvement.  How do our baselines for Q2 2009 compare to our baselines for Q2 2008? Are we as a company getting more efficient and effective at software development?


== 1.3 Benefits of SPPM for developers ==

SPPM provides important benefits for
developers as well.  Developers wish to work more efficiently and
effectively.  One way they do this is by learning from their current and
prior professional experiences about what works and what doesn't work.  A
second way is through reading technical publications which contain research
and case studies on new tools, techniques, and practices.  However, these
articles often do not contain sufficient detail for developers to
understand how to apply the practices to their own circumstances, or
whether the benefits claimed for the organization in the case study would
occur in their own organization, which might differ in significant ways.

Software project portfolio management provides a new way for developers to
learn how to work more efficiently and effectively, because it provides
them with new visibility into the projects within their own organization.
First, it enables developers to become more easily aware of projects that
are similar to their own, but that might differ along one or more objective
or subjective dimensions.  Such projects provide a valuable opportunity to
developers in both projects to gain insight into what is causing the
differences between projects in the same organization that are otherwise
similar.   Specifically, developers can learn:
  * Which projects in the company are like their own with respect to process and product measures?  
  * Are the trends in our project over time similar to the trends in other projects?  
  * Are there other projects that have already acquired expertise with specific tools or techniques that we are just now adopting? 

== 1.4 Making it practical ==

To be feasible and effective at the scale of hundreds of projects, SPPM
data collection and analysis must be as automated as possible and incur
little to no chronic overhead on developers or project teams.  The most
reasonable way to accomplish this is by restricting data collection
activities to what can be obtained via the continuous integration build
process, the source code control system, and the issue management system.

The benefit to this restriction is that the data collection process is
almost entirely transparent to the development team.

The cost of this approach is that certain kinds of data cannot be
collected.  For example, it is possible to instrument the individual
developer's editing tool (such as Eclipse or Visual Studio) in order to
detect when and whether the individual is practicing Test-Driven Design
techniques.  To obtain the "global" perspective on the organization's
software project portfolio, it is necessary to trade-off some of the more
detailed data analyses possible by intruding on the individual developer's
environment.

Given this restriction, what kinds of data can actually be collected?  The following table presents an ininitial list, organized by the source of the information.  "Build" means the continuous integration build tool such as [http://cruisecontrol.sourceforge.net/ CruiseControl] or [https://hudson.dev.java.net/ Hudson], "CM" means the configuration management tool such as [http://subversion.tigris.org/ Subversion] or [http://www.perforce.com/ Perforce], and "Issues" means the issue management system such as [http://www.atlassian.com/software/jira/ Jira] or [http://www.bugzilla.org/ Bugzilla].

|| *Source*  || *Data*  || *Description/Purpose* ||
|| Build     || Code Size and Type  || The overall size of the system in LOC, as well as size of the consitutent source code types (Java, C++, Ruby, JSP, C#, ASP, etc.) provides valuable contextual information about the project.  This helps identify similar projects and supports baselines for subsets of the overall portfolio.  For example, Java complexity might have a different baseline than Ruby complexity. Code size and type can be automatically collected for a wide variety of languages using the open source tool [http://code.google.com/p/sclc/ SCLC]. ||
|| Build     || Complexity || Source code complexity measures like [http://en.wikipedia.org/wiki/Cyclomatic_complexity cyclomatic complexity] provide an indicator of how difficult a module is to understand, test, and enhance. Cyclomatic complexity can be determined for Java code using the open source tool [http://www.kclee.com/clemens/java/javancss/ JavaNCSS].  ||
|| Build || Coupling || [http://en.wikipedia.org/wiki/Coupling_(computer_science) Software coupling] measures the dependencies among program modules.  Like complexity, coupling provides an indicator of how difficult a module will be to understand, test, and enhance. However, while complexity focuses on internal structure, coupling focuses on external structure. [http://depfind.sourceforge.net/ DependencyFinder] is an open source tool for obtaining coupling information. ||
|| Build || Coverage || [http://en.wikipedia.org/wiki/Code_coverage Code coverage] measures the degree to which source code is exercised by its tests.  Coverage provides an indicator of the quality of testing, which is itself an indicator of the readiness of the code for use, as well as the adequacy of the testing procedures in use by the development team.  [http://www.atlassian.com/software/clover/ Clover] is a commercial tool for measuring coverage in Java. ||
|| Build || CI Failures || [http://en.wikipedia.org/wiki/Continuous_Integration Continuous Integration] failures measures the average number of times per month that a project fails the continuous integration process.  This is an indicator of development stability.  A project with healthy development practices will tend to have a low number of CI build failures over the course of a month. || 
|| CM  || Commits || The number of commits to the configuration management system provides an indicator of project activity. Each project will tend to have a "normal" level of commits per day and/or per developer  based upon the project's overall nature and current state. Departures from that baseline level indicate changes to the project, and projects with radically different baseline levels of commits indicate projects with significantly different development procedures. ||
|| CM  || Churn || Associated with each commit is "churn", which is a measure of the number of lines of code added, deleted, and changed as a result of that commit.  Like commits, churn is a measure of project activity, and has similar applications to the creation of baseline values and comparison within and between projects. ||
|| Issues  || Closure rate || Closure rate measures the number of open issues that are closed by a project during a given period of time.  It is an indicator of both project activity and project "progress". Closure rate is difficult to apply across projects, since the value of closure rate is quite dependent upon the way issues are recorded in a project.  One project might track many very small tasks, while another project might track much larger tasks.  The first project might have a much higher closure rate than the second, but this does not necessarily indicate more forward progress than the second. Nevertheless, changes to the baseline closure rate within a project can indicate changes to the project state. ||





= 2.0 Software Project Portfolio Management Applications =

== 2.1 Internal Benchmarking ==

This section will overview the use of internal benchmarks.  The opportunity for a large company is that they do not have to rely on external benchmarks, they can use their own portfolio.  This can increase buy-in from developers since (a) all projects are being compared within the same company, reducing the charge that the comparison is unfair, and (b) if a project A compares unfavorably to project B, it is possible to investigate the differences in detail and determine why the projects differ along the chosen dimension, and what action to take, if any.  This is not possible when comparing an internal project to a published industry benchmark.

Benefit to management:  better visibility into projects and their comparative performance. 

Benefit to developers:  out of the dozens or hundreds of projects, which ones are comparable? Which ones are doing better?  This represents opportunities for learning, improvement, and reuse. 

== 2.2 Continuous Integration ICU ==

In a nutshell, provides an "early warning system" to both developers and managers regarding projects that may be in trouble. 
More details in [ContinuousIntegrationICU The Continuous Integration ICU].


== 2.3 Developer Expertise Browser ==

In a large company with dozens or hundreds of developers, there are pockets of expertise that are not exploited in a "just in time" manner. 

By combining commit information with structural information, a profile of each developer in terms of the libraries they work on can be automatically built.  This enables developers to easily find others in the organization who might be able to help them solve a problem or acquire a new technology.






