#summary A brief introduction to Hackystat, with pictures.

== What is Hackystat? ===

Hackystat is a framework for collection, analysis, visualization, interpretation, annotation, and dissemination of software development process and product data.  This is an ambitious goal, and in order to address it, Hackystat is organized as a collection of loosely coupled software services that communicate using [http://en.wikipedia.org/wiki/Representational_State_Transfer REST architectural principles].  The following diagram shows a standard set of Hackystat services that are organized together in a standard way:

[http://hackystat.googlecode.com/svn/wiki/architecture.gif]

Starting at the bottom, the blue boxes represent "sensors".  Sensors are small software plugins that typically collect data from the use of software development tools.  A Hackystat sensor could also collect data directly from developers, but since developers tend to be quite busy, we generally try to avoid requiring the developer to provide low-level data to the environment manually.  

Sensors send their data to a repository called the !SensorBase, represented here by a purple box.  In this drawing, there is only one !SensorBase, but the Hackystat architecture is designed to make it simple to distribute data among many !SensorBase instances if that is required. The !SensorBase also provides a repository for three other fundamental resources in Hackystat besides sensor data: sensor data types, users, and projects.  We'll get back to those later. 

Sensor data tends to be quite low-level and voluminous, and in most cases needs to be analyzed and abstracted in some way in order for it to be of use to developers.  The green boxes represent examples of Hackystat analysis services.  The !DailyProjectData analysis provides a set of abstractions generated from all of the raw sensor data for a given day and project. The Telemetry analysis takes !DailyProjectData analyses along with raw data from the !SensorBase and combines it together to produce trend-based information about software development. 

Finally, the gold boxes represent user interface services, which provide information from the Framework to the user, and in some cases allow the user to feed information back into the Framework.  For example, the !ProjectViewer displays both data from the !SensorBase and !DailyProjectData analyses, as well as allowing the user to create and modify Project definitions which are stored in the !SensorBase.  Hackystat user interfaces need not be limited to web browsers, and we are exploring alternative user interface mechanisms such as ambient devices. 

In keeping with REST architectural principles, all of the arrows in this
diagram represent communication among services using standard HTTP GET,
PUT, POST, and DELETE operations. One implication is that Hackystat is
quite platform and technology neutral: a sensor implemented using Java
could collect raw data that is analyzed with a service implemented using
.NET, and the results could be presented to the user with an interface
implemented using Ruby on Rails.

=== Registering and sending data ===

To use Hackystat, you begin by registering for an account with a Hackystat !SensorBase.  You can download and install your own local !SensorBase service and then register with it, or you can register with the [http://dasha.ics.hawaii.edu:9876/sensorbase/register public SensorBase server] maintained by the [http://csdl.ics.hawaii.edu Collaborative Software Development Laboratory] at the [http://www.hawaii.edu University of Hawaii].  Whichever way you go, you will get the following screen:

[http://hackystat.googlecode.com/svn/wiki/register1.gif]

After typing in your email address, the system will send you an email with the password to your newly created account:

[http://hackystat.googlecode.com/svn/wiki/register4.gif]

Now that you have an account, you can download and install sensors.  For example, the Emacs sensor collects data about the files you are editing.  Here is an image of my Emacs window at the moment that I am typing this documentation.  The upper window shows the file I am editing, and the lower window, which is normally hidden, shows the Hackystat Emacs sensor at work in the background, recording information about the file I am editing. 

[http://hackystat.googlecode.com/svn/wiki/emacs.gif]

Sensors are available for many other development tools. For a complete list, see the [ComponentDirectory Component Directory].

=== Displaying Sensor Data ===

Once you have installed and configured your sensors, you can go back to working on your projects in the normal way.  The Hackystat sensors will unobtrusively monitor your development activities and send sensor data off to the !SensorBase server with which you are registered.  

There are many different ways to see what sensor data is being sent to the server.  The !SensorDataViewer is a near-real time monitor that polls the !SensorBase periodically and reports on what data was received at the !SensorBase by you.  Here is an example of the data I am sending as I work on this documentation:

[http://hackystat.googlecode.com/svn/wiki/sensordataviewer.gif]

The !SensorDataViewer is a useful way to see if your sensors are working after you have installed them, and what data is being sent about your activities to the !SensorBase. 

Another user interface to sensor data is the !SensorDataBrowser, which allows you to view not just the most recently arrived data, but all of the data you have ever sent:

[http://hackystat.googlecode.com/svn/wiki/sensordatabrowser.gif]

This image shows that on this day, I have so far sent 3,634 sensor data instances to this !SensorBase. It also shows the variety of data I have sent, including CodeIssue data from Checkstyle, !UnitTest data from JUnit, FileMetric data from SCLC, and so forth.  Of course, just as with the !SensorDataBrowser, you can drill down to see the individual sensor data instances and their contents. 












This page will include the following sections:

  * Why you might be interested in Hackystat
  * The registration page.
  * What happens after sensors are installed.
  * Showing raw sensor data at the !SensorBase.
  * Showing telemetry streams and why they are interesting.
  * Showing project status.
  * What to do next. 

